use std::sync::mpsc::Receiver;
use std::sync::{mpsc, Arc, Mutex};
use std::thread;

pub mod advanced_features;
pub mod closed_iter;
pub mod collect;
pub mod concurrent;
pub mod enum_match;
pub mod guess;
pub mod hello_world;
pub mod ownership;
pub mod package_crate_use;
pub mod panic;
pub mod pub_use;
pub mod smart_point;
pub mod struct_def;
pub mod type_trait_life;

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<Receiver<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv();

            match message {
                Ok(job) => {
                    println!("Worker {id} got a job; executing.");

                    job();
                }
                Err(_) => {
                    println!("Worker {id} disconnected; shutting down.");
                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}

pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: Option<mpsc::Sender<Job>>,
}
// struct Job;

type Job = Box<dyn FnOnce() + Send + 'static>;
impl ThreadPool {
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender: Some(sender) }
    }

    //é—­åŒ…ä½œä¸ºå‚æ•°æ—¶å¯ä»¥ä½¿ç”¨ä¸‰ä¸ªä¸åŒçš„ traitï¼šFnã€FnMut å’Œ FnOnceã€‚
    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.as_ref().unwrap().send(job).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {
        drop(self.sender.take());
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);
            // å¦‚æœ Worker å­˜æ”¾çš„æ˜¯ Option<thread::JoinHandle<()>ï¼Œå°±å¯ä»¥åœ¨ Option ä¸Šè°ƒç”¨ take æ–¹æ³•å°†å€¼ä» Some æˆå‘˜ä¸­ç§»åŠ¨å‡ºæ¥è€Œå¯¹ None æˆå‘˜ä¸åšå¤„ç†ã€‚
            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

pub mod unit_test {
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    fn subtract(a: i32, b: i32) -> i32 {
        a - b
    }

    #[cfg(test)]
    mod test {
        use super::*;
        // æµ‹è¯•ç¤¾åŒºä¸­ä¸€ç›´å­˜åœ¨å…³äºæ˜¯å¦åº”è¯¥å¯¹ç§æœ‰å‡½æ•°ç›´æ¥è¿›è¡Œæµ‹è¯•çš„è®ºæˆ˜ï¼Œè€Œåœ¨å…¶ä»–è¯­è¨€ä¸­æƒ³è¦æµ‹è¯•ç§æœ‰å‡½æ•°æ˜¯ä¸€ä»¶å›°éš¾çš„ï¼Œç”šè‡³æ˜¯ä¸å¯èƒ½çš„äº‹ã€‚
        // ä¸è¿‡æ— è®ºä½ åšæŒå“ªç§æµ‹è¯•æ„è¯†å½¢æ€ï¼ŒRust çš„ç§æœ‰æ€§è§„åˆ™ç¡®å®å…è®¸ä½ æµ‹è¯•ç§æœ‰å‡½æ•°ã€‚
        #[test]
        fn test_add_success() {
            assert_eq!(add(1, 2), 3);
        }

        #[test]
        fn test_add_fair() {
            assert_eq!(add(1, 2), 4);
        }

        #[test]
        #[ignore]
        fn test_add_ignore() {}

        #[test]
        #[should_panic(expected = "test panic")]
        fn test_add_panic() {
            panic!("test panic")
        }

        #[test]
        fn test_subtract_success() {
            assert_eq!(subtract(1, 2), -1);
        }
    }
}

pub mod base_theory {
    pub mod variable {
        /// å˜é‡é»˜è®¤ä¸å¯å˜ï¼Œmutå…³é”®å­—å¯ä»¥ä½¿å˜é‡å¯å˜
        pub fn variable_immutable() {
            let x = 5;
            println!("x = {}", x);
            // cannot assign twice to immutable variable
            // x = 6;

            let mut y = 1;
            y = 2;
        }

        /// å¸¸é‡
        pub fn constants() {
            // ä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨ mutã€‚å¸¸é‡ä¸å…‰é»˜è®¤ä¸å¯å˜ï¼Œå®ƒæ€»æ˜¯ä¸å¯å˜ã€‚å£°æ˜å¸¸é‡ä½¿ç”¨ const å…³é”®å­—è€Œä¸æ˜¯ letï¼Œå¹¶ä¸” å¿…é¡» æ³¨æ˜å€¼çš„ç±»å‹ã€‚
            const MAX_POINTS: i32 = 100_000;
            println!("MAX_POINTS = {}", MAX_POINTS);
        }

        /// å˜é‡é®è”½
        pub fn shadowing() {
            // ç¬¬äºŒä¸ªå˜é‡â€œé®è”½â€äº†ç¬¬ä¸€ä¸ªå˜é‡ï¼Œæ­¤æ—¶ä»»ä½•ä½¿ç”¨è¯¥å˜é‡åçš„è¡Œä¸ºä¸­éƒ½ä¼šè§†ä¸ºæ˜¯åœ¨ä½¿ç”¨ç¬¬äºŒä¸ªå˜é‡ï¼Œç›´åˆ°ç¬¬äºŒä¸ªå˜é‡è‡ªå·±ä¹Ÿè¢«éšè—æˆ–ç¬¬äºŒä¸ªå˜é‡çš„ä½œç”¨åŸŸç»“æŸã€‚
            // å¯ä»¥ç”¨ç›¸åŒå˜é‡åç§°æ¥éšè—ä¸€ä¸ªå˜é‡ï¼Œä»¥åŠé‡å¤ä½¿ç”¨ let å…³é”®å­—æ¥å¤šæ¬¡éšè—
            // éšè—ä¸å°†å˜é‡æ ‡è®°ä¸º mut æ˜¯æœ‰åŒºåˆ«çš„ã€‚å½“ä¸å°å¿ƒå°è¯•å¯¹å˜é‡é‡æ–°èµ‹å€¼æ—¶ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ let å…³é”®å­—ï¼Œå°±ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯ã€‚é€šè¿‡ä½¿ç”¨ letï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸ªå€¼è¿›è¡Œä¸€äº›è®¡ç®—ï¼Œä¸è¿‡è®¡ç®—å®Œä¹‹åå˜é‡ä»ç„¶æ˜¯ä¸å¯å˜çš„ã€‚
            // mut ä¸éšè—çš„å¦ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œå½“å†æ¬¡ä½¿ç”¨ let æ—¶ï¼Œå®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹ï¼Œå¹¶ä¸”å¤ç”¨è¿™ä¸ªåå­—ã€‚
            let x = 5;
            let x = x + 1;
            println!("x = {}", x);
            let x = "   ";
            let x = x.len();
            println!("x = {}", x);
        }
    }

    pub mod data_types {
        /// æ•°æ®ç±»å‹ï¼šæ ‡é‡ç±»å‹å’Œå¤åˆç±»å‹
        pub fn data_types() {
            // Rust æ˜¯ é™æ€ç±»å‹ï¼ˆstatically typedï¼‰è¯­è¨€ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ç¼–è¯‘æ—¶å°±å¿…é¡»çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹ã€‚
            // æ ¹æ®å€¼åŠå…¶ä½¿ç”¨æ–¹å¼ï¼Œç¼–è¯‘å™¨é€šå¸¸å¯ä»¥æ¨æ–­å‡ºæˆ‘ä»¬æƒ³è¦ç”¨çš„ç±»å‹ã€‚å½“å¤šç§ç±»å‹å‡æœ‰å¯èƒ½æ—¶ï¼Œæ¯”å¦‚ä½¿ç”¨ parse å°† String è½¬æ¢ä¸ºæ•°å­—æ—¶ï¼Œå¿…é¡»å¢åŠ ç±»å‹æ³¨è§£ã€‚

            // æ ‡é‡ç±»å‹ï¼šæ•´å‹ã€æµ®ç‚¹å‹ã€å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹ã€‚

            // æ•´æ•°ç±»å‹
            // æœ‰ç¬¦å·æ•°ä»¥è¡¥ç å½¢å¼å­˜å‚¨ã€‚
            // æ¯ä¸€ä¸ªæœ‰ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜åŒ…å«ä» -(2çš„(n - 1)æ¬¡æ–¹) åˆ° 2çš„(n - 1)æ¬¡æ–¹ - 1 åœ¨å†…çš„æ•°å­—ï¼Œè¿™é‡Œ n æ˜¯å˜ä½“ä½¿ç”¨çš„ä½æ•°ã€‚æ‰€ä»¥ i8 å¯ä»¥å‚¨å­˜ä» -(2çš„7æ¬¡æ–¹) åˆ° 2çš„7æ¬¡æ–¹ - 1 åœ¨å†…çš„æ•°å­—ï¼Œä¹Ÿå°±æ˜¯ä» -128 åˆ° 127ã€‚
            // æ— ç¬¦å·çš„å˜ä½“å¯ä»¥å‚¨å­˜ä» 0 åˆ° 2çš„næ¬¡æ–¹ - 1 çš„æ•°å­—ï¼Œæ‰€ä»¥ u8 å¯ä»¥å‚¨å­˜ä» 0 åˆ° 2çš„8æ¬¡æ–¹ - 1 çš„æ•°å­—ï¼Œä¹Ÿå°±æ˜¯ä» 0 åˆ° 255ã€‚
            // å¦å¤–ï¼Œisize å’Œ usize ç±»å‹ä¾èµ–è¿è¡Œç¨‹åºçš„è®¡ç®—æœºæ¶æ„ï¼š64 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 64 ä½çš„ï¼Œ32 ä½æ¶æ„ä¸Šå®ƒä»¬æ˜¯ 32 ä½çš„ã€‚
            // å¤šç§æ•°å­—ç±»å‹çš„æ•°å­—å­—é¢å€¼å…è®¸ä½¿ç”¨ç±»å‹åç¼€ï¼Œä¾‹å¦‚ 57u8 æ¥æŒ‡å®šç±»å‹ï¼ŒåŒæ—¶ä¹Ÿå…è®¸ä½¿ç”¨ _ åšä¸ºåˆ†éš”ç¬¦ä»¥æ–¹ä¾¿è¯»æ•°ï¼Œ
            // æ•°å­—ç±»å‹é»˜è®¤æ˜¯ i32ã€‚isize æˆ– usize ä¸»è¦ä½œä¸ºæŸäº›é›†åˆçš„ç´¢å¼•ã€‚
            // æ³¨æ„ï¼šæ•´å‹æº¢å‡º
            let a: i8 = 1;
            println!("a = {}", a);
            let b: u16 = 2_000u16;
            println!("b = {}", b);

            // æµ®ç‚¹ç±»å‹
            // Rust çš„æµ®ç‚¹æ•°ç±»å‹æ˜¯ f32 å’Œ f64ï¼Œåˆ†åˆ«å  32 ä½å’Œ 64 ä½ã€‚é»˜è®¤ç±»å‹æ˜¯ f64ï¼Œå› ä¸ºåœ¨ç°ä»£ CPU ä¸­ï¼Œå®ƒä¸ f32 é€Ÿåº¦å‡ ä¹ä¸€æ ·ï¼Œä¸è¿‡ç²¾åº¦æ›´é«˜ã€‚æ‰€æœ‰çš„æµ®ç‚¹å‹éƒ½æ˜¯æœ‰ç¬¦å·çš„ã€‚
            let f1: f32 = 1.0;
            println!("f1 = {}", f1);
            let f2 = 1.0;
            println!("f2 = {}", f2);

            // å¸ƒå°”ç±»å‹
            let d: bool = true;
            println!("d = {}", d);

            // å­—ç¬¦ç±»å‹
            // å•å¼•å·å£°æ˜ char å­—é¢é‡ï¼Œè€Œä¸ä¹‹ç›¸åçš„æ˜¯ï¼Œä½¿ç”¨åŒå¼•å·å£°æ˜å­—ç¬¦ä¸²å­—é¢é‡ã€‚
            // Rust çš„ char ç±»å‹çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚ï¼Œå¹¶ä»£è¡¨äº†ä¸€ä¸ª Unicode æ ‡é‡å€¼ï¼ˆUnicode Scalar Valueï¼‰ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥æ¯” ASCII è¡¨ç¤ºæ›´å¤šå†…å®¹ã€‚
            let c = 'z';
            let z: char = 'â„¤'; // with explicit type annotation
            let heart_eyed_cat = 'ğŸ˜»';
            println!("c = {}, z = {}, heart_eyed_cat = {}", c, z, heart_eyed_cat);

            // å¤åˆç±»å‹: Rust æœ‰ä¸¤ä¸ªåŸç”Ÿçš„å¤åˆç±»å‹ï¼šå…ƒç»„ï¼ˆtupleï¼‰å’Œæ•°ç»„ï¼ˆarrayï¼‰ã€‚
            // å…ƒç»„ç±»å‹
            // å…ƒç»„æ˜¯ä¸€ä¸ªå°†å¤šä¸ªå…¶ä»–ç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚å…ƒç»„é•¿åº¦å›ºå®šï¼šä¸€æ—¦å£°æ˜ï¼Œå…¶é•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ã€‚
            // æˆ‘ä»¬ä½¿ç”¨åŒ…å«åœ¨åœ†æ‹¬å·ä¸­çš„é€—å·åˆ†éš”çš„å€¼åˆ—è¡¨æ¥åˆ›å»ºä¸€ä¸ªå…ƒç»„ã€‚å…ƒç»„ä¸­çš„æ¯ä¸€ä¸ªä½ç½®éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œè€Œä¸”è¿™äº›ä¸åŒå€¼çš„ç±»å‹ä¹Ÿä¸å¿…æ˜¯ç›¸åŒçš„ã€‚
            // æ¨¡å¼åŒ¹é…ï¼ˆpattern matchingï¼‰æ¥è§£æ„ï¼ˆdestructureï¼‰å…ƒç»„å€¼
            // ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„æœ‰ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå«åš å•å…ƒï¼ˆunitï¼‰ å…ƒç»„ã€‚è¿™ç§å€¼ä»¥åŠå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ ()ï¼Œè¡¨ç¤ºç©ºå€¼æˆ–ç©ºçš„è¿”å›ç±»å‹ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œåˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼ã€‚
            let tup: (i32, f64, char, bool) = (1, 1.1, '2', true);
            let (x, y, z, b) = tup;
            println!("x = {}, y = {}, z = {},b = {}", x, y, z, b);
            // ä¹Ÿå¯ä»¥ä½¿ç”¨ç‚¹å·ï¼ˆ.ï¼‰åè·Ÿå€¼çš„ç´¢å¼•æ¥ç›´æ¥è®¿é—®å®ƒä»¬ã€‚
            println!(
                "tup.0 = {}, tup.1 = {}, tup.2 = {}, tup.3 = {}",
                tup.0, tup.1, tup.2, tup.3
            );

            // æ•°ç»„ç±»å‹
            // æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹å¿…é¡»ç›¸åŒã€‚
            // åœ¨æ ˆï¼ˆstackï¼‰è€Œä¸æ˜¯åœ¨å †ï¼ˆheapï¼‰ä¸Šä¸ºæ•°æ®åˆ†é…ç©ºé—´ï¼Œæˆ–è€…æ˜¯æƒ³è¦ç¡®ä¿æ€»æ˜¯æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ æ—¶ï¼Œæ•°ç»„éå¸¸æœ‰ç”¨ã€‚
            //  collect ç±»å‹æ˜¯æ ‡å‡†åº“æä¾›çš„ä¸€ä¸ª å…è®¸ å¢é•¿å’Œç¼©å°é•¿åº¦çš„ç±»ä¼¼æ•°ç»„çš„é›†åˆç±»å‹ã€‚å½“ä¸ç¡®å®šæ˜¯åº”è¯¥ä½¿ç”¨æ•°ç»„è¿˜æ˜¯ collect çš„æ—¶å€™ï¼Œé‚£ä¹ˆå¾ˆå¯èƒ½åº”è¯¥ä½¿ç”¨ collectã€‚
            // æ•°ç»„çš„ç±»å‹ï¼šåœ¨æ–¹æ‹¬å·ä¸­åŒ…å«æ¯ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œåè·Ÿåˆ†å·ï¼Œå†åè·Ÿæ•°ç»„å…ƒç´ çš„æ•°é‡ã€‚
            // ä½¿ç”¨ç´¢å¼•æ¥è®¿é—®æ•°ç»„çš„å…ƒç´ 
            // æ³¨æ„ï¼šç´¢å¼•è¶Šç•Œ
            let arr: [u32; 5] = [1, 2, 3, 4, 5];
            println!(
                "arr[0] = {}, arr[1] = {}, arr[2] = {}, arr[3] = {}, arr[4] = {}",
                arr[0], arr[1], arr[2], arr[3], arr[4]
            );
            // println!("arr = {:?}", arr);
            // åœ¨æ–¹æ‹¬å·ä¸­æŒ‡å®šåˆå§‹å€¼åŠ åˆ†å·å†åŠ å…ƒç´ ä¸ªæ•°çš„æ–¹å¼æ¥åˆ›å»ºä¸€ä¸ªæ¯ä¸ªå…ƒç´ éƒ½ä¸ºç›¸åŒå€¼çš„æ•°ç»„
            let arr2 = [3; 5];
            println!(
                "arr2[0] = {}, arr2[1] = {}, arr2[2] = {}, arr2[3] = {}, arr2[4] = {}",
                arr2[0], arr2[1], arr2[2], arr2[3], arr2[4]
            );
            // println!("arr2 = {:?}", arr2);
        }

        /// æ•°å€¼è¿ç®—
        pub fn number_compute() {
            // addition
            let sum = 5 + 10;
            println!("sum = {}", sum);

            // subtraction
            let difference = 95.5 - 4.3;
            println!("difference = {}", difference);

            // multiplication
            let product = 4 * 30;
            println!("product = {}", product);

            // division
            // æ•´æ•°é™¤æ³•ä¼šå‘é›¶èˆå…¥åˆ°æœ€æ¥è¿‘çš„æ•´æ•°ã€‚
            let quotient = 56.7 / 32.2;
            let truncated = -5 / 3; // ç»“æœä¸º -1
            println!("quotient = {}, truncated = {}", quotient, truncated);

            // remainder
            let remainder = 43 % 5;
            println!("remainder = {}", remainder);
        }
    }

    pub mod function {
        /// å‡½æ•°å®šä¹‰
        pub fn function(a: i32) {
            // fn å…³é”®å­—ï¼Œå®ƒç”¨æ¥å£°æ˜æ–°å‡½æ•°ã€‚
            // Rust ä»£ç ä¸­çš„å‡½æ•°å’Œå˜é‡åä½¿ç”¨ snake case è§„èŒƒé£æ ¼ã€‚åœ¨ snake case ä¸­ï¼Œæ‰€æœ‰å­—æ¯éƒ½æ˜¯å°å†™å¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯ã€‚
            // Rust ä¸­é€šè¿‡è¾“å…¥ fn åé¢è·Ÿç€å‡½æ•°åå’Œä¸€å¯¹åœ†æ‹¬å·æ¥å®šä¹‰å‡½æ•°ã€‚å¤§æ‹¬å·å‘Šè¯‰ç¼–è¯‘å™¨å“ªé‡Œæ˜¯å‡½æ•°ä½“çš„å¼€å§‹å’Œç»“å°¾ã€‚
            // Rust ä¸å…³å¿ƒå‡½æ•°å®šä¹‰æ‰€åœ¨çš„ä½ç½®ï¼Œåªè¦å‡½æ•°è¢«è°ƒç”¨æ—¶å‡ºç°åœ¨è°ƒç”¨ä¹‹å¤„å¯è§çš„ä½œç”¨åŸŸå†…å°±è¡Œã€‚

            // å‚æ•°ï¼ˆparametersï¼‰çš„å‡½æ•°ï¼Œå‚æ•°æ˜¯ç‰¹æ®Šå˜é‡ï¼Œæ˜¯å‡½æ•°ç­¾åçš„ä¸€éƒ¨åˆ†ã€‚
            // å½“å‡½æ•°æ‹¥æœ‰å‚æ•°ï¼ˆå½¢å‚ï¼‰æ—¶ï¼Œå¯ä»¥ä¸ºè¿™äº›å‚æ•°æä¾›å…·ä½“çš„å€¼ï¼ˆå®å‚ï¼‰ã€‚æŠ€æœ¯ä¸Šè®²ï¼Œè¿™äº›å…·ä½“å€¼è¢«ç§°ä¸ºå‚æ•°ï¼ˆargumentsï¼‰
            // åœ¨å‡½æ•°ç­¾åä¸­ï¼Œå¿…é¡» å£°æ˜æ¯ä¸ªå‚æ•°çš„ç±»å‹ã€‚
            // å½“å®šä¹‰å¤šä¸ªå‚æ•°æ—¶ï¼Œä½¿ç”¨é€—å·åˆ†éš”
            println!("a = {}", a);
            // è¯­å¥å’Œè¡¨è¾¾å¼
            // å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—çš„è¯­å¥å’Œä¸€ä¸ªå¯é€‰çš„ç»“å°¾è¡¨è¾¾å¼æ„æˆã€‚
            // Rust æ˜¯ä¸€é—¨åŸºäºè¡¨è¾¾å¼ï¼ˆexpression-basedï¼‰çš„è¯­è¨€ï¼Œè¿™æ˜¯ä¸€ä¸ªéœ€è¦ç†è§£çš„ï¼ˆä¸åŒäºå…¶ä»–è¯­è¨€ï¼‰é‡è¦åŒºåˆ«ã€‚

            // è¯­å¥ï¼ˆStatementsï¼‰æ˜¯æ‰§è¡Œä¸€äº›æ“ä½œä½†ä¸è¿”å›å€¼çš„æŒ‡ä»¤ã€‚ è¡¨è¾¾å¼ï¼ˆExpressionsï¼‰è®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼ã€‚
            // è¯­å¥: å¦‚å˜é‡ç»‘å®šã€å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯è¯­å¥
            let y = 6;
            println!("y = {}", y);
            // let y = 6 è¯­å¥å¹¶ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥æ²¡æœ‰å¯ä»¥ç»‘å®šåˆ° x ä¸Šçš„å€¼ã€‚
            // let x = (let y = 6);
            // è¡¨è¾¾å¼ï¼šè¡¨è¾¾å¼å¯ä»¥æ˜¯è¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œå‡½æ•°è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚ç”¨å¤§æ‹¬å·åˆ›å»ºçš„ä¸€ä¸ªæ–°çš„å—ä½œç”¨åŸŸä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼
            // æ³¨æ„ y+1 è¿™ä¸€è¡Œåœ¨ç»“å°¾æ²¡æœ‰åˆ†å·ã€‚è¡¨è¾¾å¼çš„ç»“å°¾æ²¡æœ‰åˆ†å·ã€‚å¦‚æœåœ¨è¡¨è¾¾å¼çš„ç»“å°¾åŠ ä¸Šåˆ†å·ï¼Œå®ƒå°±å˜æˆäº†è¯­å¥ï¼Œè€Œè¯­å¥ä¸ä¼šè¿”å›å€¼ã€‚
            let x = {
                let y = 3;
                y + 1
            };
            println!("x = {}", x);
        }

        /// è¿”å›å€¼
        pub fn return_function(a: i32) -> i32 {
            // å‡½æ•°è¿”å›å€¼
            // å‡½æ•°å¯ä»¥å‘è°ƒç”¨å®ƒçš„ä»£ç è¿”å›å€¼ã€‚æˆ‘ä»¬å¹¶ä¸å¯¹è¿”å›å€¼å‘½åï¼Œä½†è¦åœ¨ç®­å¤´ï¼ˆ->ï¼‰åå£°æ˜å®ƒçš„ç±»å‹ã€‚
            // åœ¨ Rust ä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ç­‰åŒäºå‡½æ•°ä½“æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ã€‚
            // ä½¿ç”¨ return å…³é”®å­—å’ŒæŒ‡å®šå€¼ï¼Œå¯ä»å‡½æ•°ä¸­æå‰è¿”å›ï¼›ä½†å¤§éƒ¨åˆ†å‡½æ•°éšå¼çš„è¿”å›æœ€åçš„è¡¨è¾¾å¼ã€‚
            // å¦‚æœåœ¨åŒ…å« x + 1 çš„è¡Œå°¾åŠ ä¸Šä¸€ä¸ªåˆ†å·ï¼ŒæŠŠå®ƒä»è¡¨è¾¾å¼å˜æˆè¯­å¥ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ä¸€ä¸ªé”™è¯¯ã€‚
            a + 1
        }
    }

    pub mod control_flow {
        /// if æ§åˆ¶
        pub fn control_if() {
            // if è¡¨è¾¾å¼ä¸­ä¸æ¡ä»¶å…³è”çš„ä»£ç å—æœ‰æ—¶è¢«å«åš arms
            // ä»£ç ä¸­çš„æ¡ä»¶ å¿…é¡» æ˜¯ bool å€¼ã€‚å¦‚æœæ¡ä»¶ä¸æ˜¯ bool å€¼ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚
            // å°† else if è¡¨è¾¾å¼ä¸ if å’Œ else ç»„åˆæ¥å®ç°å¤šé‡æ¡ä»¶ã€‚
            //  Rust åªä¼šæ‰§è¡Œç¬¬ä¸€ä¸ªæ¡ä»¶ä¸º true çš„ä»£ç å—ï¼Œå¹¶ä¸”ä¸€æ—¦å®ƒæ‰¾åˆ°ä¸€ä¸ªä»¥åï¼Œç”šè‡³éƒ½ä¸ä¼šæ£€æŸ¥å‰©ä¸‹çš„æ¡ä»¶äº†ã€‚
            let number = 6;
            if number % 4 == 0 {
                println!("number is divisible by 4");
            } else if number % 3 == 0 {
                println!("number is divisible by 3");
            } else if number % 2 == 0 {
                println!("number is divisible by 2");
            } else {
                println!("number is not divisible by 4, 3, or 2");
            }

            // åœ¨ let è¯­å¥ä¸­ä½¿ç”¨ if
            // if æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ let è¯­å¥çš„å³ä¾§ä½¿ç”¨å®ƒ
            // if çš„æ¯ä¸ªåˆ†æ”¯çš„å¯èƒ½çš„è¿”å›å€¼éƒ½å¿…é¡»æ˜¯ç›¸åŒç±»å‹
            let condition = true;
            let number = if condition { 5 } else { 6 };
            // let number = if condition { 5 } else { "six" };
            println!("The value of number is: {number}");
        }

        /// å¾ªç¯
        pub fn control_loops() {
            // å¾ªç¯
            // Rust æœ‰ä¸‰ç§ç±»å‹çš„å¾ªç¯ï¼šloopã€while å’Œ forã€‚
            //  å¾ªç¯ä¸­çš„ continue å…³é”®å­—å‘Šè¯‰ç¨‹åºè·³è¿‡è¿™ä¸ªå¾ªç¯è¿­ä»£ä¸­çš„ä»»ä½•å‰©ä½™ä»£ç ï¼Œå¹¶è½¬åˆ°ä¸‹ä¸€ä¸ªè¿­ä»£ã€‚
            println!("loop start:-------------------");
            control_loop();
            println!("loop end:-------------------");
            println!("while start:-------------------");
            control_while();
            println!("while end:-------------------");
            println!("for start:-------------------");
            control_for();
            println!("for end:-------------------");
        }

        /// loop å¾ªç¯
        pub fn control_loop() {
            // loop å¾ªç¯
            // loop å¾ªç¯ä¼šä¸€ç›´è¿è¡Œä¸‹å»ï¼Œç›´åˆ°è¢«æ˜¾å¼åœ°ç»“æŸã€‚
            // ä»å¾ªç¯è¿”å›å€¼
            // ä½¿ç”¨ break å…³é”®å­—è¿”å›å€¼ counter * 2ã€‚å¾ªç¯ä¹‹åï¼Œæˆ‘ä»¬é€šè¿‡åˆ†å·ç»“æŸèµ‹å€¼ç»™ result çš„è¯­å¥ã€‚
            let mut counter = 0;
            let result = loop {
                if counter == 5 {
                    break counter * 2;
                }
                counter += 1
            };
            println!("result = {}", result);

            // å¾ªç¯æ ‡ç­¾ï¼šåœ¨å¤šä¸ªå¾ªç¯ä¹‹é—´æ¶ˆé™¤æ­§ä¹‰
            // å¦‚æœå­˜åœ¨åµŒå¥—å¾ªç¯ï¼Œbreak å’Œ continue åº”ç”¨äºæ­¤æ—¶æœ€å†…å±‚çš„å¾ªç¯ã€‚
            // ä½ å¯ä»¥é€‰æ‹©åœ¨ä¸€ä¸ªå¾ªç¯ä¸ŠæŒ‡å®šä¸€ä¸ª å¾ªç¯æ ‡ç­¾ï¼ˆloop labelï¼‰ï¼Œç„¶åå°†æ ‡ç­¾ä¸ break æˆ– continue ä¸€èµ·ä½¿ç”¨ï¼Œä½¿è¿™äº›å…³é”®å­—åº”ç”¨äºå·²æ ‡è®°çš„å¾ªç¯è€Œä¸æ˜¯æœ€å†…å±‚çš„å¾ªç¯ã€‚

            let mut count = 0;
            'loop1: loop {
                println!("count = {}", count);
                let mut inner_count = 10;
                'loop2: loop {
                    println!("inner_count = {}", inner_count);
                    if inner_count == 9 {
                        break;
                    }
                    if count == 2 {
                        break 'loop1;
                    }
                    inner_count -= 1;
                }
                count += 1;
            }
        }

        /// while å¾ªç¯
        pub fn control_while() {
            // while å¾ªç¯
            // while å¾ªç¯ä¼šä¸€ç›´è¿è¡Œä¸‹å»ï¼Œç›´åˆ°æ¡ä»¶ä¸º falseã€‚
            // while å¾ªç¯å’Œ loop å¾ªç¯ä¸€æ ·ï¼Œéƒ½æœ‰è¿”å›å€¼ã€‚
            // while å¾ªç¯å’Œ loop å¾ªç¯ä¸€æ ·ï¼Œéƒ½æœ‰ continue å…³é”®å­—ã€‚
            let mut number = 3;
            while number != 0 {
                println!("{number}!");
                number -= 1;
            }
            println!("LIFTOFF!!!");
        }

        /// for å¾ªç¯
        pub fn control_for() {
            let arr = [2; 5];
            for ele in arr {
                println!("ele = {}", ele);
            }
            println!("-----------------");
            for ele in arr.iter() {
                println!("ele = {}", ele);
            }
            println!("-----------------");

            //  Rangeï¼Œå®ƒæ˜¯æ ‡å‡†åº“æä¾›çš„ç±»å‹ï¼Œç”¨æ¥ç”Ÿæˆä»ä¸€ä¸ªæ•°å­—å¼€å§‹åˆ°å¦ä¸€ä¸ªæ•°å­—ä¹‹å‰ç»“æŸçš„æ‰€æœ‰æ•°å­—çš„åºåˆ—ã€‚
            // revï¼Œç”¨æ¥åè½¬ rangeã€‚
            for num in (1..4).rev() {
                println!("{}!", num);
            }
            println!("LIFTOFF!!!");
        }
    }
}
