fn dynamically_sized_types() {
    // 动态大小类型（dynamically sized types）
    // 这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。

    // str 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道其大小，也就意味着不能创建 str 类型的变量，也不能获取 str 类型的参数。
    // let s1: str = "Hello there!";
    // let s2: str = "How's it going?";

    // Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。
    // 如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。
    // 这也就是为什么不可能创建一个存放动态大小类型的变量的原因。

    // &str 则是 两个 值：str 的地址和其长度。
    // 这样，&str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，我们总是知道 &str 的大小，而无论其引用的字符串是多长。
    // 这里是 Rust 中动态大小类型的常规用法：它们有一些额外的元信息来储存动态信息的大小。
    // 这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。

    let a = Box::new("hello");
}

// 为了处理 DST，Rust 提供了 Sized trait 来决定一个类型的大小是否在编译时可知。
// 这个 trait 自动为编译器在编译时就知道大小的类型实现。
// 另外，Rust 隐式的为每一个泛型函数增加了 Sized bound。
fn generic<T>(t: T) {
    // --snip--
}
// 实际上被当作如下处理：
fn generic2<T: Sized>(t: T) {
    // --snip--
}

// 泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：
// ?Sized 上的 trait bound 意味着 “T 可能是也可能不是 Sized” 同时这个注解会覆盖泛型类型必须在编译时拥有固定大小的默认规则。
// 这种意义的 ?Trait 语法只能用于 Sized ，而不能用于任何其他 trait。
// 另外注意我们将 t 参数的类型从 T 变为了 &T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。
fn generic3<T: ?Sized>(t: &T) {
    // --snip--
}
